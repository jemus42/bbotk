#' @title Optimization via Local Search
#'
#' @include Optimizer.R
#' @name mlr_optimizers_local_search
#'
#' @description
#' `OptimizerLocalSearch` class that implements a simple Local Search.
#' Local Search starts by determining the `mu` initial best points present in the [Archive] of the [Instance].
#' If fewer points than `mu` are present, additional points sampled uniformly at random are evaluated.
#'
#' In each iteration, for each of the `mu` initial best points, `n_points` neighbors are generated by local mutation.
#' Local mutation samples a single parameter that is to be mutated and then proceeds as follows:
#' Numeric parameters ([paradox::ParamDbl]) are mutated via Gaussian mutation (using `sigma` scaled by the range of the parameter as a standard deviation).
#' Integer parameters ([paradox::ParamInt]) undergo the same mutation but are rounded to the closest integer after mutation.
#' Categorical parameters ([paradox::ParamFct] and [paradox::ParamLgl]) are mutated via uniform mutation.
#' Note that parameters that are conditioned on (i.e., they are parents of a [paradox::Condition], see the dependencies of the search space) are not mutated.
#'
#' If `update_mu_points_after_eval` is `TRUE`, the `mu` best initial points are updated after each iteration resulting in a more focused search.
#'
#' @templateVar id local_search
#' @template section_dictionary_optimizers
#'
#' @section Parameters:
#' \describe{
#' \item{`mu`}{`integer(1)`\cr
#'   Size of the initial best points which are used as a starting point for the Local Search.
#'   Default is `10`.
#' }
#' \item{`n_points`}{`integer(1)`\cr
#'   Number of neighboring points to generate for each of the `mu` best starting points in each iteration.
#'   Default is `100`.
#' }
#' \item{`sigma`}{`numeric(1)`\cr
#'   Standard deviation used for mutation of numeric parameters.
#'   Number of neighboring points to generate for each of the `mu` starting points in each iteration.
#'   Default is `0.05`.
#' }
#' \item{`update_mu_points_after_eval`}{`logical(1)`\cr
#'   Should the `mu` best initial points be updated after each iteration?
#'   Default is `FALSE`.
#' }
#' }
#'
#' @template section_progress_bars
#'
#' @export
#' @template example
OptimizerLocalSearch = R6Class("OptimizerLocalSearch",
  inherit = Optimizer,
  public = list(

    #' @description
    #' Creates a new instance of this [R6][R6::R6Class] class.
    initialize = function() {
      param_set = ps(
        mu = p_int(lower = 1L, default = 10L, tags = "required"),
        n_points = p_int(lower = 1L, default = 100L, tags = "required"),
        sigma = p_dbl(lower = 0L, default = 0.05, tags = "required"),
        update_mu_points_after_eval = p_lgl(default = FALSE, tags = "required")
      )
      param_set$values = list(mu = 10L, n_points = 100L, sigma = 0.05, update_mu_points_after_eval = FALSE)

      super$initialize(
        id = "local_search",
        param_set = param_set,
        param_classes = c("ParamLgl", "ParamInt", "ParamDbl", "ParamFct"),
        properties = c("dependencies", "single-crit", "multi-crit"),
        label = "Local Search",
        man = "mlr3mbo::mlr_optimizers_local_search"
      )
    }
  ),

  private = list(
    .optimize = function(inst) {
      mu = self$param_set$values$mu
      n_points = self$param_set$values$n_points
      sigma = self$param_set$values$sigma
      update_mu_points_after_eval = self$param_set$values$update_mu_points_after_eval

      # if no reference points in archive, generate mu by sampling uniformly at random
      if (nrow(inst$archive$data) < mu) {
        sampler = SamplerUnif$new(inst$search_space)
        design = sampler$sample(mu - nrow(inst$archive$data))
        inst$eval_batch(design$data)
      }
      points = inst$archive$best(n_select = mu)[, inst$archive$cols_x, with = FALSE]

      # we do not mutate parents of conditions
      ids_to_mutate = setdiff(inst$search_space$ids(), unique(inst$search_space$deps$on)) 

      # get ranges of numeric params for mutation
      ids_numeric = intersect(names(which(inst$search_space$is_number)), ids_to_mutate)
      ranges = map(ids_numeric, function(id) {
        inst$search_space$params[[id]]$upper - inst$search_space$params[[id]]$lower
      })
      names(ranges) = ids_numeric

      repeat {  # iterate until we have an exception from eval_batch
        neighbors = map_dtr(seq_len(nrow(points)), function(i) {
          map_dtr(seq_len(n_points), function(j) {
            mutate_point(points[i, ], search_space = inst$search_space, ranges = ranges, ids_to_mutate = ids_to_mutate, sigma = sigma)
          })
        })
        inst$eval_batch(neighbors)
        if (update_mu_points_after_eval) {
          points = inst$archive$best(n_select = mu)[, inst$archive$cols_x, with = FALSE]
        }
      }
    }
  )
)

mlr_optimizers$add("local_search", OptimizerLocalSearch)

mutate_point = function(point, search_space, ranges, ids_to_mutate, sigma = 0.05) {
  neighbor = copy(point)
  valid_ids_to_mutate = intersect(names(which(!map_lgl(neighbor, is.na))), ids_to_mutate)
  id = sample(valid_ids_to_mutate, size = 1L)
  neighbor[1L, ][[id]] = mutate(neighbor[1L, ][[id]], param = search_space$params[[id]], range = ranges[[id]], sigma = sigma)
  neighbor
}

mutate = function(value, param, range, sigma) {
  if (is.na(value)) {
    return(value)
  }
  stopifnot(param$class %in% c("ParamDbl", "ParamFct", "ParamInt", "ParamLgl"))
  if (param$class %in% c("ParamDbl", "ParamInt")) {
    value = stats::rnorm(1L, mean = value, sd = sigma * range)
    if (param$class == "ParamInt") {
      value = round(value, 0L)
    }
    value = min(max(value, param$lower), param$upper)
  } else if (param$class %in% c("ParamFct", "ParamLgl")) {
    value = sample(param$levels, size = 1L)
  }
  value
}

